{% extends 'base.html' %}

{% block title %}Rehab Session - Home Rehab Coach{% endblock %}

{% block header %}
<header class="header">
    <h1>üèãÔ∏è Rehab Session</h1>
    <nav class="nav-links">
        <a href="{{ url_for('patient_dashboard') }}">‚Üê Back to Dashboard</a>
    </nav>
</header>
{% endblock %}

{% block content %}
<div class="session-layout">
    <!-- Video Panel -->
    <div class="video-panel">
    <div class="skeleton-overlay">
        <strong>Skeleton Tracking: ON</strong><br />
        <small>Pose detection active</small>
    </div>

    <div class="video-placeholder" style="height:420px; padding:0; overflow:hidden; position:relative;">
        <video id="webcamVideo" autoplay playsinline muted
                style="width:100%; height:100%; object-fit: cover; background:#000;"></video>

        <div id="camErrorOverlay"
            style="display:none; position:absolute; inset:0; align-items:center; justify-content:center; flex-direction:column; color:#fff; background:rgba(0,0,0,0.6);">
        <div class="icon">üìπ</div>
        <p>Live Webcam Feed</p>
        <p style="font-size: 0.8rem; opacity: 0.85;">Allow camera access to start</p>
        </div>
    </div>
    </div>

    <!-- Feedback Panel -->
    <div class="feedback-panel">
        <!-- Rep Counter -->
        <div class="rep-counter">
            <div class="count">
                <span id="repCountText">0</span> / <span id="repTargetText">10</span>
            </div>
            <div class="label">
                Reps (Set <span id="setIndexText">1</span> of <span id="setsTotalText">3</span>)
            </div>
        </div>

        <!-- Form Status -->
        <div class="form-status">
            <h4 style="margin-bottom: 10px;">Form Status</h4>
            <div id="statusIndicator" class="status-indicator correct">‚úì CORRECT FORM</div>
            <div style="margin-top: 10px; text-align:center; color:#666;">
                Score: <span id="frameScoreText">--</span> / 50
            </div>
        </div>

        <!-- Real-time Feedback -->
        <div class="error-messages">
            <h4>Real-time Feedback</h4>
            <div id="feedbackList">
                <div class="error-item">Waiting for feedback...</div>
            </div>
        </div>

        <!-- Language -->
        <div class="card" style="padding: 12px;">
            <h4 style="margin-bottom:8px;">Language</h4>
            <select id="languageSelect" class="form-control">
                <option value="English" selected>English</option>
                <option value="Tamil">Tamil</option>
                <option value="Chinese">Chinese</option>
                <option value="Malay">Malay</option>
                <option value="Thai">Thai</option>
            </select>
            <div style="font-size:0.8rem; opacity:0.7; margin-top:6px;">
                API: <span id="apiBaseText">--</span>
            </div>
        </div>

        <!-- Audio -->
        <div class="audio-indicator" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
            <div style="display:flex; align-items:center; gap:10px;">
                <div class="audio-icon">üîä</div>
                <div>
                    <strong>Voice Feedback: <span id="voiceStatusText">ON</span></strong><br>
                    <small id="voiceHintText">Audio cues are active</small>
                </div>
            </div>
            <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                <input id="voiceToggle" type="checkbox" checked />
                <span style="font-weight:600;">Enable</span>
            </label>
        </div>
        <!-- Exercise Mode -->
        <div class="card" style="padding:15px;">
            <h4>Exercise Mode</h4>

            <div style="margin-bottom:10px;">
                <label>
                    <input type="radio" name="exerciseMode" value="auto" checked>
                    Auto Detect
                </label>
                &nbsp;&nbsp;
                <label>
                    <input type="radio" name="exerciseMode" value="manual">
                    Manual Select
                </label>
            </div>

            <select id="manualExerciseSelect" class="form-control" disabled>
                <option value="squat">Squat</option>
                <option value="lifting_of_arms">Lifting of Arms</option>
                <option value="lateral_trunk_tilt">Lateral Trunk Tilt</option>
                <option value="trunk_rotation">Trunk Rotation</option>
                <option value="pelvis_rotation">Pelvis Rotation</option>
            </select>
        </div>
        <!-- Exercise Info -->
        <div class="card" style="padding: 15px;">
            <h4>Current Exercise</h4>
            <p style="font-size: 0.85rem; margin-top: 10px;" id="exerciseMetaText">
                Target: --<br />
                ROM Target: --
            </p>
            <p style="font-size:0.9rem; margin-top:10px;">
                Detected: <strong id="detectedExerciseText">--</strong>
            </p>
        </div>

        <!-- Controls -->
        <div class="session-controls">
            <button id="pauseBtn" class="btn" style="flex: 1;">‚è∏Ô∏è Pause</button>
            <button id="stopBtn" class="btn btn-danger" style="flex: 1;">‚èπÔ∏è Stop Session</button>
        </div>

        <a href="{{ url_for('pain_checkin') }}" class="btn btn-success" style="text-align: center;">
            Complete Set ‚Üí Check-in
        </a>
    </div>
</div>

<script>
/* ===================== CONFIG ===================== */

const API_BASE = window.location.origin;
document.getElementById("apiBaseText").textContent = API_BASE;

const THRESHOLD = 30.0;
const COOLDOWN_SECONDS = 2;
const POLL_MS = 66; //2000 , 66

const LANG_TO_BCP47 = {
  English: "en-US",
  Tamil: "ta-IN",
  Chinese: "zh-CN",
  Malay: "ms-MY",
  Thai: "th-TH",
};

/* ===================== DOM ===================== */

const VIDEO = document.getElementById("webcamVideo");
const camErrorOverlay = document.getElementById("camErrorOverlay");

const statusIndicator = document.getElementById("statusIndicator");
const scoreSpan = document.getElementById("frameScoreText");
const feedbackBox = document.getElementById("feedbackList");

const voiceToggle = document.getElementById("voiceToggle");
const voiceStatusText = document.getElementById("voiceStatusText");
const voiceHintText = document.getElementById("voiceHintText");

const languageSelect = document.getElementById("languageSelect");

const repCountText = document.getElementById("repCountText");
const repTargetText = document.getElementById("repTargetText");
const setIndexText = document.getElementById("setIndexText");
const setsTotalText = document.getElementById("setsTotalText");

const detectedExerciseText = document.getElementById("detectedExerciseText");
const exerciseMetaText = document.getElementById("exerciseMetaText");

const pauseBtn = document.getElementById("pauseBtn");
const stopBtn  = document.getElementById("stopBtn");

const canvas = document.createElement("canvas");
const ctx = canvas.getContext("2d");

/* ===================== STATE ===================== */
let exerciseMode = "auto";
let manualExercise = "squat";

const modeRadios = document.querySelectorAll("input[name='exerciseMode']");
const manualSelect = document.getElementById("manualExerciseSelect");

modeRadios.forEach(r => {
  r.addEventListener("change", () => {
    exerciseMode = r.value;

    if (exerciseMode === "manual") {
      manualSelect.disabled = false;
    } else {
      manualSelect.disabled = true;
    }
  });
});

if (manualSelect) {
  manualSelect.addEventListener("change", () => {
    manualExercise = manualSelect.value;
  });
}

let isPaused = false;
let pollTimer = null;
let inflight = false;

let LAST_FEEDBACK = null;
let LAST_FEEDBACK_TIME = 0;

let lastSpokenHash = "";
let lastSpokenAt = 0;
const SPEAK_COOLDOWN_MS = 8000;

function getLanguageName() {
  return languageSelect ? languageSelect.value : "English";
}
function getLanguageCode() {
  return LANG_TO_BCP47[getLanguageName()] || "en-US";
}

/* ===================== EXERCISE PLAN UI ===================== */

const EXERCISE_PLAN = {
  "lifting_of_arms":    { reps: 10, sets: 3, target: "3 sets √ó 10 reps", rom: "Raise arms to shoulder height" },
  "lateral_trunk_tilt": { reps: 10, sets: 3, target: "3 sets √ó 10 reps", rom: "Tilt ~20‚Äì30¬∞ each side" },
  "trunk_rotation":     { reps: 10, sets: 3, target: "3 sets √ó 10 reps", rom: "Rotate comfortably (no pain)" },
  "pelvis_rotation":    { reps: 10, sets: 3, target: "3 sets √ó 10 reps", rom: "Small controlled pelvis rotation" },
  "squat":              { reps: 10, sets: 3, target: "3 sets √ó 10 reps", rom: "Hip crease to knee level (as tolerated)" },
  "idle":            { reps: 0, sets: 0, target: "You are Idle", rom: "--" },
};

function normalizeExerciseName(name) {
  if (!name) return "idle";
  const n = name.toLowerCase().trim();

  if (n.includes("squat")) return "squat";
  if (n.includes("lifting")) return "lifting_of_arms";
  if (n.includes("lateral")) return "lateral_trunk_tilt";
  if (n.includes("trunk")) return "trunk_rotation";
  if (n.includes("pelvis")) return "pelvis_rotation";

  if (EXERCISE_PLAN[n]) return n;
  return "idle";
}

function updateExerciseUI(exerciseNameRaw) {
  const key = normalizeExerciseName(exerciseNameRaw);
  const plan = EXERCISE_PLAN[key] || EXERCISE_PLAN["unknown"];

  if (detectedExerciseText) detectedExerciseText.textContent = key.replaceAll("_", " ");
  if (exerciseMetaText) {
    exerciseMetaText.innerHTML = `Target: ${plan.target}<br />ROM Target: ${plan.rom}`;
  }
}

/* ===================== UI HELPERS ===================== */

function setStatus(status, score) {
  scoreSpan.textContent = Number(score || 0).toFixed(2);
  statusIndicator.classList.remove("correct", "incorrect");

  if (status === "CORRECT") {
    statusIndicator.classList.add("correct");
    statusIndicator.textContent = "‚úì CORRECT FORM";
  } else if (status === "WRONG") {
    statusIndicator.classList.add("incorrect");
    statusIndicator.textContent = "‚úó FORM NEEDS ADJUSTMENT";
  } else if (status === "NO_POSE") {
    statusIndicator.classList.add("incorrect");
    statusIndicator.textContent = "‚Ä¶ POSE NOT DETECTED";
  } else if (status === "NO_FRAME") {
    statusIndicator.classList.add("incorrect");
    statusIndicator.textContent = "‚Ä¶ NO FRAME";
  } else if (status === "WARMUP") {
    statusIndicator.classList.add("incorrect");
    statusIndicator.textContent = "‚Ä¶ WARMING UP";
  } else if (status === "ERROR") {
    statusIndicator.classList.add("incorrect");
    statusIndicator.textContent = "‚úó ERROR";
  } else {
    statusIndicator.classList.add("incorrect");
    statusIndicator.textContent = "‚Ä¶ PROCESSING";
  }
}

function renderFeedback(items) {
  if (items && items.length > 0) {
    LAST_FEEDBACK = items;
    LAST_FEEDBACK_TIME = Date.now();
  }

  const displayItems = (LAST_FEEDBACK && LAST_FEEDBACK.length > 0) ? LAST_FEEDBACK : null;
  feedbackBox.innerHTML = "";

  if (!displayItems) {
    const div = document.createElement("div");
    div.className = "error-item";
    div.textContent = "Waiting for feedback...";
    feedbackBox.appendChild(div);
    return;
  }

  displayItems.slice(0, 4).forEach((txt) => {
    const div = document.createElement("div");
    div.className = "error-item";
    div.textContent = "‚ö†Ô∏è " + txt;
    feedbackBox.appendChild(div);
  });

  const ageSec = Math.round((Date.now() - LAST_FEEDBACK_TIME) / 1000);
  const ts = document.createElement("div");
  ts.style.fontSize = "0.8rem";
  ts.style.opacity = "0.6";
  ts.style.marginTop = "8px";
  ts.textContent = `Last updated ${ageSec}s ago`;
  feedbackBox.appendChild(ts);
}

/* ===================== SERVER TTS ===================== */

/* ===================== SERVER TTS (FIXED) ===================== */

let ttsAudio = null;
let isSpeaking = false;
let ttsQueue = [];

function setVoiceUI(on) {
  if (voiceStatusText) voiceStatusText.textContent = on ? "ON" : "OFF";
  if (voiceHintText) voiceHintText.textContent = on ? "Audio cues are active" : "Audio cues are muted";
}

function stopSpeaking() {
  try {
    if (ttsAudio) {
      ttsAudio.pause();
      ttsAudio.src = "";
      ttsAudio = null;
    }
  } catch (e) {}
  ttsQueue = [];
  isSpeaking = false;
}

async function playNextTTS() {
  if (ttsQueue.length === 0) {
    isSpeaking = false;
    return;
  }

  isSpeaking = true;
  const text = ttsQueue.shift();
  const language = getLanguageName();

  try {
    const res = await fetch(`${API_BASE}/api/tts`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text, language })
    });

    if (!res.ok) {
      console.error("TTS HTTP error", res.status);
      isSpeaking = false;
      return;
    }

    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    ttsAudio = new Audio(url);

    // üî• Faster playback
    ttsAudio.playbackRate = 1.25;

    ttsAudio.onended = () => {
      URL.revokeObjectURL(url);
      playNextTTS();
    };

    await ttsAudio.play();

  } catch (e) {
    console.error("TTS error:", e);
    isSpeaking = false;
  }
}

function queueSpeech(text) {
  if (!text) return;
  if (voiceToggle && !voiceToggle.checked) return;

  ttsQueue.push(text);

  if (!isSpeaking) {
    playNextTTS();
  }
}

async function speakText(text) {
  if (!text) return;
  queueSpeech(text);
}

async function speakFeedbackList(items) {
  if (!items || items.length === 0) return;

  const now = Date.now();
  if (now - lastSpokenAt < SPEAK_COOLDOWN_MS) return;

  const hash = items.join("|");
  if (hash === lastSpokenHash) return;

  const short = items.slice(0, 2).join(". ");
  queueSpeech(short);

  lastSpokenHash = hash;
  lastSpokenAt = now;
}

if (voiceToggle) {
  setVoiceUI(voiceToggle.checked);

  voiceToggle.addEventListener("change", () => {
    setVoiceUI(voiceToggle.checked);
    if (!voiceToggle.checked) stopSpeaking();
  });
}

if (languageSelect) {
  languageSelect.addEventListener("change", async () => {
    stopSpeaking();
    await startSession();
  });
}

/* ===================== WEBCAM ===================== */

async function startWebcam() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    if (camErrorOverlay) camErrorOverlay.style.display = "flex";
    return false;
  }

  try {
    const constraints = { video: { facingMode: "user" }, audio: false };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);

    VIDEO.srcObject = stream;
    await new Promise((resolve) => { VIDEO.onloadedmetadata = () => resolve(); });
    await VIDEO.play();

    if (camErrorOverlay) camErrorOverlay.style.display = "none";
    return true;
  } catch (err) {
    console.error("Camera error:", err);
    if (camErrorOverlay) camErrorOverlay.style.display = "flex";
    return false;
  }
}

function stopCamera() {
  try {
    if (VIDEO && VIDEO.srcObject) {
      VIDEO.srcObject.getTracks().forEach(t => t.stop());
      VIDEO.srcObject = null;
    }
  } catch (e) {
    console.warn("stopCamera failed:", e);
  }
}

function pauseCameraPreview() {
  try { VIDEO.pause(); } catch(e) {}
}

async function resumeCameraPreview() {
  try { await VIDEO.play(); } catch(e) {}
}

/* ===================== BACKEND ===================== */

async function startSession() {
  try {
    await fetch(`${API_BASE}/api/session/start`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        threshold: THRESHOLD,
        cooldown_seconds: COOLDOWN_SECONDS,
        language: getLanguageName(),
      })
    });
  } catch (e) {
    console.error("startSession failed:", e);
    setStatus("ERROR", 0);
    renderFeedback(["Network error: failed to reach backend (session start)"]);
  }
}

function grabFrameDataURL() {
  const w = VIDEO.videoWidth, h = VIDEO.videoHeight;
  if (!w || !h) return null;

  const targetW = 640;
  const targetH = Math.round((h / w) * targetW);

  canvas.width = targetW;
  canvas.height = targetH;
  ctx.drawImage(VIDEO, 0, 0, targetW, targetH);
  return canvas.toDataURL("image/jpeg", 0.65);
}

function updateRepUIFromOut(out) {
  // ‚úÖ preferred: rep_info object from backend
  if (out && out.rep_info && typeof out.rep_info === "object") {
    const r = out.rep_info;
    if (repCountText && r.rep_now != null) repCountText.textContent = r.rep_now;
    if (repTargetText && r.rep_target != null) repTargetText.textContent = r.rep_target;
    if (setIndexText && r.set_now != null) setIndexText.textContent = r.set_now;
    if (setsTotalText && r.set_target != null) setsTotalText.textContent = r.set_target;
    return;
  }

  // fallback: if you ever return flat keys
  if (repCountText && out.rep_count != null) repCountText.textContent = out.rep_count;
  if (repTargetText && out.rep_target != null) repTargetText.textContent = out.rep_target;
  if (setIndexText && out.set_index != null) setIndexText.textContent = out.set_index;
  if (setsTotalText && out.sets_total != null) setsTotalText.textContent = out.sets_total;
}

async function pollFeedback() {
  if (inflight) return;
  inflight = true;

  const frame_b64 = grabFrameDataURL();
  if (!frame_b64) {
    inflight = false;
    return;
  }

  try {
    const res = await fetch(`${API_BASE}/api/live_feedback`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      //body: JSON.stringify({ frame_b64, language: getLanguageName() })
      body: JSON.stringify({
            frame_b64,
            language: getLanguageName(),
            mode: exerciseMode,
            manual_exercise: manualExercise
          })
    });

    const out = await res.json().catch(() => ({}));

    // ‚úÖ always update rep UI if present
    updateRepUIFromOut(out);

    // ‚úÖ detected exercise + meta
    if (out.exercise_name) updateExerciseUI(out.exercise_name);

    if (!res.ok) {
      setStatus("ERROR", 0);
      renderFeedback([out.error || `Backend error (HTTP ${res.status})`]);
      return;
    }

    setStatus(out.form_status, out.frame_score);

    let fb = out.llm_feedback;
    if (typeof fb === "string") fb = [fb];
    renderFeedback(fb);

    if (out.form_status === "WRONG" && fb && fb.length > 0) {
      await speakFeedbackList(fb);
    }

  } catch (e) {
    console.error("pollFeedback failed:", e);
    setStatus("ERROR", 0);
    renderFeedback(["Network error: failed to reach backend"]);
  } finally {
    inflight = false;
  }
}

function startPolling() {
  if (pollTimer) clearInterval(pollTimer);
  pollTimer = setInterval(() => {
    if (!isPaused) pollFeedback();
  }, POLL_MS);
}

function stopPolling() {
  if (pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
  }
}

/* ===================== BUTTONS ===================== */

if (pauseBtn) {
  pauseBtn.addEventListener("click", async () => {
    isPaused = !isPaused;
    if (isPaused) {
      pauseBtn.textContent = "‚ñ∂Ô∏è Resume";
      pauseCameraPreview();
      stopSpeaking();
    } else {
      pauseBtn.textContent = "‚è∏Ô∏è Pause";
      await resumeCameraPreview();
      await pollFeedback();
    }
  });
}

if (stopBtn) {
  stopBtn.addEventListener("click", async () => {
    isPaused = true;
    stopPolling();
    stopCamera();
    stopSpeaking();

    if (pauseBtn) pauseBtn.disabled = true;
    stopBtn.disabled = true;
    stopBtn.textContent = "‚úÖ Session Stopped";

    setStatus("NO_FRAME", 0);
    renderFeedback(["Session stopped."]);
  });
}

/* ===================== INIT ===================== */

(async function init() {
    const camOk = await startWebcam();
    if (!camOk) return;

    await startSession();
    await pollFeedback();
    startPolling();
})();
</script>
{% endblock %}