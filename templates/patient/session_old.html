{% extends 'base.html' %}

{% block title %}Rehab Session - Home Rehab Coach{% endblock %}

{% block header %}
<header class="header">
  <h1>üèãÔ∏è Rehab Session</h1>
  <nav class="nav-links">
    <a href="{{ url_for('patient_dashboard') }}">‚Üê Back to Dashboard</a>
  </nav>
</header>
{% endblock %}

{% block content %}
<div class="session-layout">
  <!-- Video Panel -->
  <div class="video-panel">
    <div class="skeleton-overlay">
      <strong>Skeleton Tracking: ON</strong><br />
      <small>Pose detection active</small>
    </div>

    <!-- REAL webcam video -->
    <div class="video-placeholder" style="height:420px; padding:0; overflow:hidden; position:relative;">

      <video id="webcamVideo"
             autoplay playsinline muted
             style="width:100%; height:100%; object-fit: cover; background:#000;">
      </video>

      <!-- overlay text if camera fails -->
      <div id="camErrorOverlay"
           style="display:none; position:absolute; inset:0; align-items:center; justify-content:center; flex-direction:column; color:#fff; background:rgba(0,0,0,0.6);">
        <div class="icon">üìπ</div>
        <p>Live Webcam Feed</p>
        <p style="font-size: 0.8rem; opacity: 0.85;">Allow camera access to start</p>
      </div>
    </div>
  </div>

  <!-- Feedback Panel -->
  <div class="feedback-panel">
    <!-- Rep Counter (placeholder) -->
    <div class="rep-counter">
      <div class="count">7 / 10</div>
      <div class="label">Reps (Set 2 of 3)</div>
    </div>

    <!-- Form Status (dynamic) -->
    <div class="form-status">
      <h4 style="margin-bottom: 10px;">Form Status</h4>

      <div id="statusIndicator" class="status-indicator correct">
        ‚úì CORRECT FORM
      </div>

      <div style="margin-top: 10px; text-align:center; color:#666;">
        Score: <span id="frameScoreText">--</span> / 50
      </div>
    </div>

    <!-- Real-time Feedback -->
    <div class="error-messages">
      <h4>Real-time Feedback</h4>
      <div id="feedbackList">
        <div class="error-item">Waiting for feedback...</div>
      </div>
    </div>

    <!-- Language -->
    <div class="card" style="padding: 12px;">
      <h4 style="margin-bottom:8px;">Language</h4>
      <select id="languageSelect" class="form-control">
        <option value="English" selected>English</option>
        <option value="Tamil">Tamil</option>
        <option value="Chinese">Chinese</option>
        <option value="Malay">Malay</option>
        <option value="Thai">Thai</option>
      </select>
      <div style="font-size:0.8rem; opacity:0.7; margin-top:8px;">
        Note: Browser voice depends on installed system voices.
      </div>
    </div>

    <!-- Audio Indicator -->
    <div class="audio-indicator" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
      <div style="display:flex; align-items:center; gap:10px;">
        <div class="audio-icon">üîä</div>
        <div>
          <strong>Voice Feedback: <span id="voiceStatusText">ON</span></strong><br>
          <small id="voiceHintText">Audio cues are active</small>
        </div>
      </div>

      <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
        <input id="voiceToggle" type="checkbox" checked />
        <span style="font-weight:600;">Enable</span>
      </label>
    </div>

    <!-- Exercise Info -->
    <div class="card" style="padding: 15px;">
      <h4>Current Exercise</h4>
      <p style="color: #666; margin-top: 5px;" id="exerciseNameText">Knee Extension</p>
      <p style="font-size: 0.85rem; margin-top: 10px;">
        Target: 3 sets √ó 10 reps<br />
        ROM Target: 90¬∞ flexion
      </p>
      <p style="font-size:0.9rem; margin-top:10px;">
        Detected: <strong id="detectedExerciseText">--</strong>
      </p>
    </div>

    <!-- Session Controls -->
    <div class="session-controls">
      <button id="pauseBtn" class="btn" style="flex: 1;">‚è∏Ô∏è Pause</button>
      <button id="stopBtn" class="btn btn-danger" style="flex: 1;">‚èπÔ∏è Stop Session</button>
    </div>

    <!-- Next Step -->
    <a href="{{ url_for('pain_checkin') }}" class="btn btn-success" style="text-align: center;">
      Complete Set ‚Üí Check-in
    </a>
  </div>
</div>

<script>
  /* ---------------- DOM ---------------- */
  const VIDEO = document.getElementById("webcamVideo");
  const camErrorOverlay = document.getElementById("camErrorOverlay");

  const statusIndicator = document.getElementById("statusIndicator");
  const scoreSpan = document.getElementById("frameScoreText");
  const feedbackBox = document.getElementById("feedbackList");

  const voiceToggle = document.getElementById("voiceToggle");
  const voiceStatusText = document.getElementById("voiceStatusText");
  const voiceHintText = document.getElementById("voiceHintText");

  const languageSelect = document.getElementById("languageSelect");

  const detectedExerciseText = document.getElementById("detectedExerciseText");

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  /* -------------- Session params -------------- */
  const THRESHOLD = 30.0;
  const COOLDOWN_SECONDS = 2;
  const POLL_MS = 2000;

  /* -------------- Sticky feedback -------------- */
  let LAST_FEEDBACK = null;
  let LAST_FEEDBACK_TIME = 0;

  /* -------------- Voice / TTS -------------- */
  let lastSpokenHash = "";
  let lastSpokenAt = 0;
  const SPEAK_COOLDOWN_MS = 8000;

  /* ---- Session control state ---- */
  let isPaused = false;
  let pollTimer = null;

  const pauseBtn = document.getElementById("pauseBtn");
  const stopBtn  = document.getElementById("stopBtn");

  /* ---------------- Language helpers ---------------- */
  const LANG_TO_BCP47 = {
    English: "en-US",
    Tamil: "ta-IN",
    Chinese: "zh-CN",
    Malay: "ms-MY",
    Thai: "th-TH",
  };

  function getLanguageName() {
    return languageSelect ? languageSelect.value : "Tamil";
  }

  function getLanguageCode() {
    return LANG_TO_BCP47[getLanguageName()] || "ta-IN";
  }

  /* ---------------- Polling control ---------------- */
  function startPolling() {
    if (pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(() => {
      if (!isPaused) pollFeedback();
    }, POLL_MS);
  }

  function stopPolling() {
    if (pollTimer) {
      clearInterval(pollTimer);
      pollTimer = null;
    }
  }

  function stopCamera() {
    try {
      if (VIDEO && VIDEO.srcObject) {
        VIDEO.srcObject.getTracks().forEach(t => t.stop());
        VIDEO.srcObject = null;
      }
    } catch (e) {
      console.warn("stopCamera failed:", e);
    }
  }

  function pauseCameraPreview() {
    try { VIDEO.pause(); } catch(e) {}
  }

  async function resumeCameraPreview() {
    try { await VIDEO.play(); } catch(e) {}
  }

  /* ---------------- Voice UI ---------------- */
  function setVoiceUI(on) {
    if (voiceStatusText) voiceStatusText.textContent = on ? "ON" : "OFF";
    if (voiceHintText) voiceHintText.textContent = on ? "Audio cues are active" : "Audio cues are muted";
  }

  function stopSpeaking() {
    try { window.speechSynthesis.cancel(); } catch(e) {}
  }

  function listVoicesDebug() {
    try {
      const voices = window.speechSynthesis.getVoices?.() || [];
      console.log("Available voices:", voices.map(v => `${v.name} | ${v.lang}`));
    } catch (e) {}
  }

  function pickVoiceForLang(langCode) {
    const voices = window.speechSynthesis.getVoices?.() || [];
    if (!voices.length) return null;

    const lc = (langCode || "en-US").toLowerCase();
    const base = lc.split("-")[0];

    // 1) exact match
    let v = voices.find(x => (x.lang || "").toLowerCase() === lc);
    if (v) return v;

    // 2) starts with base (ta / zh / ms / th)
    v = voices.find(x => (x.lang || "").toLowerCase().startsWith(base));
    if (v) return v;

    // 3) special for Chinese: accept any zh-*
    if (base === "zh") {
      v = voices.find(x => (x.lang || "").toLowerCase().startsWith("zh"));
      if (v) return v;
    }

    // 4) fallback to English
    return voices.find(x => (x.lang || "").toLowerCase().startsWith("en")) || voices[0] || null;
  }

  function speakText(text) {
    if (!text || !window.speechSynthesis) return;
    if (voiceToggle && !voiceToggle.checked) return;

    stopSpeaking();

    const u = new SpeechSynthesisUtterance(text);
    const langCode = getLanguageCode();
    u.lang = langCode;

    const chosen = pickVoiceForLang(langCode);
    if (chosen) u.voice = chosen;

    console.log("TTS desired lang:", langCode, "chosen:", chosen?.name, chosen?.lang);
    window.speechSynthesis.speak(u);
  }

  function speakFeedbackList(items) {
    if (!items || items.length === 0) return;

    const now = Date.now();
    if (now - lastSpokenAt < SPEAK_COOLDOWN_MS) return;

    const hash = items.join("|");
    if (hash === lastSpokenHash) return;

    const short = items.slice(0, 2).join(". ");
    speakText(short);

    lastSpokenHash = hash;
    lastSpokenAt = now;
  }

  if (voiceToggle) {
    setVoiceUI(voiceToggle.checked);
    voiceToggle.addEventListener("change", () => {
      setVoiceUI(voiceToggle.checked);
      if (!voiceToggle.checked) stopSpeaking();
    });
  }

  /* Warm up voices (important on Chrome/macOS) */
  function warmupVoices() {
    try { window.speechSynthesis.getVoices(); } catch(e) {}
    listVoicesDebug();
  }
  if (window.speechSynthesis) {
    window.speechSynthesis.onvoiceschanged = warmupVoices;
    warmupVoices();
  }

  // stop reading when language changes + update backend language
  if (languageSelect) {
    languageSelect.addEventListener("change", async () => {
      stopSpeaking();
      warmupVoices();
      await startSession();
      // optional: immediate poll so UI updates quickly
      await pollFeedback();
    });
  }

  /* ---------------- Webcam ---------------- */
  async function startWebcam() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      console.error("getUserMedia not available");
      if (camErrorOverlay) camErrorOverlay.style.display = "flex";
      return false;
    }

    try {
      const constraints = { video: { facingMode: "user" }, audio: false };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);

      VIDEO.srcObject = stream;
      VIDEO.onloadedmetadata = async () => {
        try { await VIDEO.play(); } catch(e) { console.error("VIDEO.play() failed", e); }
      };

      if (camErrorOverlay) camErrorOverlay.style.display = "none";
      return true;
    } catch (err) {
      console.error("Camera error:", err);
      if (camErrorOverlay) camErrorOverlay.style.display = "flex";
      return false;
    }
  }

  /* ---------------- Backend session init ---------------- */
  async function startSession() {
    try {
      await fetch("/api/session/start", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          threshold: THRESHOLD,
          cooldown_seconds: COOLDOWN_SECONDS,
          language: getLanguageName(),
        })
      });
    } catch (e) {
      console.error("startSession failed:", e);
    }
  }

  /* ---------------- Frame capture ---------------- */
  function grabFrameDataURL() {
    const w = VIDEO.videoWidth, h = VIDEO.videoHeight;
    if (!w || !h) return null;

    const targetW = 640;
    const targetH = Math.round((h / w) * targetW);

    canvas.width = targetW;
    canvas.height = targetH;
    ctx.drawImage(VIDEO, 0, 0, targetW, targetH);

    return canvas.toDataURL("image/jpeg", 0.65);
  }

  /* ---------------- UI update helpers ---------------- */
  function setStatus(status, score) {
    scoreSpan.textContent = Number(score || 0).toFixed(2);

    statusIndicator.classList.remove("correct", "incorrect");

    if (status === "CORRECT") {
      statusIndicator.classList.add("correct");
      statusIndicator.textContent = "‚úì CORRECT FORM";
    } else if (status === "WRONG") {
      statusIndicator.classList.add("incorrect");
      statusIndicator.textContent = "‚úó FORM NEEDS ADJUSTMENT";
    } else if (status === "NO_POSE") {
      statusIndicator.classList.add("incorrect");
      statusIndicator.textContent = "‚Ä¶ POSE NOT DETECTED";
    } else if (status === "NO_FRAME") {
      statusIndicator.classList.add("incorrect");
      statusIndicator.textContent = "‚Ä¶ NO FRAME";
    } else if (status === "WARMUP") {
      statusIndicator.classList.add("incorrect");
      statusIndicator.textContent = "‚Ä¶ WARMING UP";
    } else if (status === "ERROR") {
      statusIndicator.classList.add("incorrect");
      statusIndicator.textContent = "‚úó ERROR";
    } else {
      statusIndicator.classList.add("incorrect");
      statusIndicator.textContent = "‚Ä¶ PROCESSING";
    }
  }

  function renderFeedback(items) {
    if (items && items.length > 0) {
      LAST_FEEDBACK = items;
      LAST_FEEDBACK_TIME = Date.now();
    }

    const displayItems = (LAST_FEEDBACK && LAST_FEEDBACK.length > 0) ? LAST_FEEDBACK : null;
    feedbackBox.innerHTML = "";

    if (!displayItems) {
      const div = document.createElement("div");
      div.className = "error-item";
      div.textContent = "Waiting for feedback...";
      feedbackBox.appendChild(div);
      return;
    }

    displayItems.slice(0, 4).forEach((txt) => {
      const div = document.createElement("div");
      div.className = "error-item";
      div.textContent = "‚ö†Ô∏è " + txt;
      feedbackBox.appendChild(div);
    });

    const ageSec = Math.round((Date.now() - LAST_FEEDBACK_TIME) / 1000);
    const ts = document.createElement("div");
    ts.style.fontSize = "0.8rem";
    ts.style.opacity = "0.6";
    ts.style.marginTop = "8px";
    ts.textContent = `Last updated ${ageSec}s ago`;
    feedbackBox.appendChild(ts);
  }

  /* ---------------- Polling ---------------- */
  async function pollFeedback() {
    const frame_b64 = grabFrameDataURL();
    if (!frame_b64) return;

    try {
      const res = await fetch("/api/live_feedback", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ frame_b64, language: getLanguageName() })
      });

      const out = await res.json();

      if (!res.ok) {
        setStatus("ERROR", 0);
        renderFeedback([out.error || "Backend error"]);
        return;
      }

      setStatus(out.form_status, out.frame_score);

      let fb = out.llm_feedback;
      if (typeof fb === "string") fb = [fb];

      renderFeedback(fb);

      if (out.form_status === "WRONG" && fb && fb.length > 0) {
        speakFeedbackList(fb);
      }

      // Show detected exercise
      if (detectedExerciseText && out.exercise_name) {
        detectedExerciseText.textContent = out.exercise_name;
      }

    } catch (e) {
      console.error("pollFeedback failed:", e);
      setStatus("ERROR", 0);
      renderFeedback(["Network error: failed to reach backend"]);
    }
  }

  /* ---------------- Buttons ---------------- */
  if (pauseBtn) {
    pauseBtn.addEventListener("click", async () => {
      isPaused = !isPaused;

      if (isPaused) {
        pauseBtn.textContent = "‚ñ∂Ô∏è Resume";
        pauseCameraPreview();
        stopSpeaking();
      } else {
        pauseBtn.textContent = "‚è∏Ô∏è Pause";
        await resumeCameraPreview();
        await pollFeedback();
      }
    });
  }

  if (stopBtn) {
    stopBtn.addEventListener("click", async () => {
      isPaused = true;
      stopPolling();
      stopCamera();
      stopSpeaking();

      if (pauseBtn) pauseBtn.disabled = true;
      stopBtn.disabled = true;
      stopBtn.textContent = "‚úÖ Session Stopped";
      setStatus("NO_FRAME", 0);
      renderFeedback(["Session stopped."]);
    });
  }

  /* ---------------- Init ---------------- */
  (async function init() {
    const camOk = await startWebcam();
    if (!camOk) return;

    await startSession();
    await pollFeedback();
    startPolling();
  })();
</script>

{% endblock %}